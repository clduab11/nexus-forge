{
  "key": "swarm-development-hierarchical-1750392742375/workflow-developer/workflow-architecture-design",
  "type": "architecture_design",
  "content": "# \ud83c\udfa8 Visual Workflow Architecture for Agent Composition\n\n## Executive Summary\n\nThis document defines the visual workflow system architecture for Nexus Forge, enabling intuitive drag-and-drop composition of multi-agent workflows with real-time execution visualization.\n\n## 1. Core Architecture Overview\n\n### 1.1 System Components\n\n```typescript\ninterface WorkflowSystem {\n  editor: WorkflowEditor;           // Visual drag-drop editor\n  runtime: WorkflowRuntime;         // Execution engine\n  visualizer: ExecutionVisualizer;  // Real-time visualization\n  serializer: WorkflowSerializer;   // Save/load workflows\n  debugger: WorkflowDebugger;       // Visual debugging tools\n}\n```\n\n### 1.2 Architecture Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Visual Workflow Layer\"\n        Editor[Workflow Editor]\n        Canvas[Drag-Drop Canvas]\n        Nodes[Agent Nodes]\n        Connections[Data Flow Connections]\n    end\n    \n    subgraph \"Workflow Engine\"\n        Parser[Workflow Parser]\n        Validator[Workflow Validator]\n        Executor[Execution Engine]\n        Monitor[Execution Monitor]\n    end\n    \n    subgraph \"Integration Layer\"\n        Orchestrator[Starri Orchestrator]\n        AgentPool[Agent Pool]\n        WebSocket[WebSocket Updates]\n        Storage[Workflow Storage]\n    end\n    \n    Editor --> Parser\n    Canvas --> Nodes\n    Nodes --> Connections\n    Parser --> Validator\n    Validator --> Executor\n    Executor --> Orchestrator\n    Monitor --> WebSocket\n    Editor --> Storage\n```\n\n## 2. Visual Workflow Components\n\n### 2.1 Node System Architecture\n\n```typescript\n// Base node interface for all workflow nodes\ninterface WorkflowNode {\n  id: string;\n  type: NodeType;\n  position: { x: number; y: number };\n  data: {\n    label: string;\n    agentType: AgentType;\n    config: AgentConfig;\n    inputs: InputPort[];\n    outputs: OutputPort[];\n  };\n  style: NodeStyle;\n  state: NodeState;\n}\n\nenum NodeType {\n  AGENT = 'agent',\n  TRIGGER = 'trigger',\n  CONDITION = 'condition',\n  TRANSFORM = 'transform',\n  OUTPUT = 'output',\n  SUBFLOW = 'subflow'\n}\n\nenum AgentType {\n  STARRI = 'starri',\n  JULES = 'jules',\n  GEMINI = 'gemini',\n  RESEARCHER = 'researcher',\n  DEVELOPER = 'developer',\n  DESIGNER = 'designer',\n  TESTER = 'tester',\n  CUSTOM = 'custom'\n}\n\ninterface InputPort {\n  id: string;\n  name: string;\n  type: DataType;\n  required: boolean;\n  connected: boolean;\n}\n\ninterface OutputPort {\n  id: string;\n  name: string;\n  type: DataType;\n  multiple: boolean;  // Can connect to multiple inputs\n}\n```\n\n### 2.2 Connection System\n\n```typescript\ninterface WorkflowConnection {\n  id: string;\n  source: {\n    nodeId: string;\n    portId: string;\n  };\n  target: {\n    nodeId: string;\n    portId: string;\n  };\n  type: ConnectionType;\n  dataTransform?: DataTransform;\n  style: ConnectionStyle;\n}\n\nenum ConnectionType {\n  DATA_FLOW = 'data',\n  CONTROL_FLOW = 'control',\n  CONDITIONAL = 'conditional',\n  PARALLEL = 'parallel',\n  SEQUENTIAL = 'sequential'\n}\n\ninterface DataTransform {\n  type: 'map' | 'filter' | 'reduce' | 'custom';\n  expression: string;\n}\n```\n\n### 2.3 Canvas and Interaction System\n\n```typescript\ninterface WorkflowCanvas {\n  nodes: Map<string, WorkflowNode>;\n  connections: Map<string, WorkflowConnection>;\n  viewport: {\n    x: number;\n    y: number;\n    zoom: number;\n  };\n  grid: {\n    size: number;\n    snap: boolean;\n    visible: boolean;\n  };\n  selection: {\n    nodes: Set<string>;\n    connections: Set<string>;\n  };\n}\n\ninterface DragDropContext {\n  draggedNode: WorkflowNode | null;\n  draggedPort: Port | null;\n  dropZones: DropZone[];\n  connectionPreview: ConnectionPreview | null;\n}\n```\n\n## 3. Workflow Serialization Format\n\n### 3.1 Workflow Definition Schema\n\n```typescript\ninterface WorkflowDefinition {\n  id: string;\n  version: string;\n  metadata: {\n    name: string;\n    description: string;\n    author: string;\n    created: Date;\n    modified: Date;\n    tags: string[];\n  };\n  nodes: WorkflowNode[];\n  connections: WorkflowConnection[];\n  variables: WorkflowVariable[];\n  triggers: WorkflowTrigger[];\n  settings: WorkflowSettings;\n}\n\ninterface WorkflowVariable {\n  name: string;\n  type: DataType;\n  defaultValue: any;\n  scope: 'global' | 'local';\n}\n\ninterface WorkflowTrigger {\n  id: string;\n  type: 'manual' | 'schedule' | 'event' | 'webhook';\n  config: TriggerConfig;\n}\n```\n\n### 3.2 JSON Serialization Example\n\n```json\n{\n  \"id\": \"wf_nexus_app_builder\",\n  \"version\": \"1.0.0\",\n  \"metadata\": {\n    \"name\": \"Full-Stack App Builder\",\n    \"description\": \"Automated full-stack application development workflow\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"node_1\",\n      \"type\": \"agent\",\n      \"position\": { \"x\": 100, \"y\": 100 },\n      \"data\": {\n        \"label\": \"Requirements Analyzer\",\n        \"agentType\": \"starri\",\n        \"config\": {\n          \"mode\": \"analyzer\",\n          \"parameters\": {\n            \"depth\": \"comprehensive\"\n          }\n        },\n        \"outputs\": [\n          {\n            \"id\": \"requirements\",\n            \"name\": \"Requirements\",\n            \"type\": \"object\"\n          }\n        ]\n      }\n    },\n    {\n      \"id\": \"node_2\",\n      \"type\": \"agent\",\n      \"position\": { \"x\": 400, \"y\": 100 },\n      \"data\": {\n        \"label\": \"Architecture Designer\",\n        \"agentType\": \"gemini\",\n        \"config\": {\n          \"model\": \"gemini-2.5-flash-thinking\"\n        },\n        \"inputs\": [\n          {\n            \"id\": \"requirements\",\n            \"name\": \"Requirements\",\n            \"type\": \"object\",\n            \"required\": true\n          }\n        ]\n      }\n    }\n  ],\n  \"connections\": [\n    {\n      \"id\": \"conn_1\",\n      \"source\": {\n        \"nodeId\": \"node_1\",\n        \"portId\": \"requirements\"\n      },\n      \"target\": {\n        \"nodeId\": \"node_2\",\n        \"portId\": \"requirements\"\n      },\n      \"type\": \"data\"\n    }\n  ]\n}\n```\n\n## 4. Drag-and-Drop Implementation\n\n### 4.1 React DnD Integration\n\n```typescript\nimport { DndProvider, useDrag, useDrop } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\n\ninterface DraggableNode {\n  type: string;\n  agentType: AgentType;\n  label: string;\n  icon: React.ComponentType;\n}\n\nconst NodePalette: React.FC = () => {\n  const availableNodes: DraggableNode[] = [\n    { type: 'agent', agentType: 'starri', label: 'Starri AI', icon: Brain },\n    { type: 'agent', agentType: 'jules', label: 'Jules Coder', icon: Code },\n    { type: 'agent', agentType: 'researcher', label: 'Researcher', icon: Search },\n    { type: 'condition', agentType: null, label: 'Condition', icon: GitBranch },\n    { type: 'transform', agentType: null, label: 'Transform', icon: Shuffle }\n  ];\n  \n  return (\n    <div className=\"node-palette\">\n      {availableNodes.map(node => (\n        <DraggableNodeItem key={node.type + node.agentType} node={node} />\n      ))}\n    </div>\n  );\n};\n```\n\n### 4.2 Canvas Drop Zone\n\n```typescript\nconst WorkflowCanvas: React.FC = () => {\n  const [nodes, setNodes] = useState<Map<string, WorkflowNode>>(new Map());\n  const [connections, setConnections] = useState<Map<string, WorkflowConnection>>(new Map());\n  \n  const [{ isOver }, drop] = useDrop({\n    accept: 'node',\n    drop: (item: DraggableNode, monitor) => {\n      const offset = monitor.getClientOffset();\n      if (offset) {\n        addNode({\n          type: item.type,\n          agentType: item.agentType,\n          position: { x: offset.x, y: offset.y }\n        });\n      }\n    },\n    collect: (monitor) => ({\n      isOver: !!monitor.isOver()\n    })\n  });\n  \n  return (\n    <div ref={drop} className=\"workflow-canvas\">\n      <svg className=\"connections-layer\">\n        {Array.from(connections.values()).map(conn => (\n          <ConnectionPath key={conn.id} connection={conn} nodes={nodes} />\n        ))}\n      </svg>\n      <div className=\"nodes-layer\">\n        {Array.from(nodes.values()).map(node => (\n          <WorkflowNodeComponent key={node.id} node={node} />\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n## 5. Real-time Execution Visualization\n\n### 5.1 Execution State Management\n\n```typescript\ninterface ExecutionState {\n  workflowId: string;\n  status: 'idle' | 'running' | 'paused' | 'completed' | 'failed';\n  nodeStates: Map<string, NodeExecutionState>;\n  dataFlow: Map<string, any>;\n  logs: ExecutionLog[];\n  metrics: ExecutionMetrics;\n}\n\ninterface NodeExecutionState {\n  nodeId: string;\n  status: 'waiting' | 'running' | 'completed' | 'failed' | 'skipped';\n  progress: number;\n  startTime?: Date;\n  endTime?: Date;\n  error?: Error;\n  output?: any;\n}\n\n// WebSocket integration for real-time updates\nconst useExecutionState = (workflowId: string) => {\n  const [executionState, setExecutionState] = useState<ExecutionState>();\n  const { subscribe } = useWebSocket();\n  \n  useEffect(() => {\n    const unsubscribe = subscribe(`workflow.${workflowId}.execution`, (update) => {\n      setExecutionState(prev => ({\n        ...prev,\n        ...update\n      }));\n    });\n    \n    return unsubscribe;\n  }, [workflowId]);\n  \n  return executionState;\n};\n```\n\n### 5.2 Visual Feedback System\n\n```typescript\nconst NodeExecutionVisualizer: React.FC<{ node: WorkflowNode; state: NodeExecutionState }> = ({ node, state }) => {\n  return (\n    <div className={`node-visualizer ${state.status}`}>\n      {state.status === 'running' && (\n        <div className=\"execution-indicator\">\n          <div className=\"pulse-animation\" />\n          <ProgressBar progress={state.progress} />\n        </div>\n      )}\n      {state.status === 'completed' && (\n        <CheckCircle className=\"status-icon success\" />\n      )}\n      {state.status === 'failed' && (\n        <AlertCircle className=\"status-icon error\" />\n      )}\n      <div className=\"execution-metrics\">\n        {state.startTime && (\n          <span className=\"metric\">\n            Duration: {calculateDuration(state.startTime, state.endTime)}\n          </span>\n        )}\n      </div>\n    </div>\n  );\n};\n```\n\n## 6. Workflow Templates and Presets\n\n### 6.1 Template System\n\n```typescript\ninterface WorkflowTemplate {\n  id: string;\n  category: TemplateCategory;\n  name: string;\n  description: string;\n  thumbnail: string;\n  workflow: WorkflowDefinition;\n  requirements: {\n    agents: AgentType[];\n    minNodes: number;\n    estimatedTime: string;\n  };\n}\n\nenum TemplateCategory {\n  WEB_APP = 'web_app',\n  MOBILE_APP = 'mobile_app',\n  API_SERVICE = 'api_service',\n  DATA_PIPELINE = 'data_pipeline',\n  AI_MODEL = 'ai_model',\n  AUTOMATION = 'automation'\n}\n\nconst workflowTemplates: WorkflowTemplate[] = [\n  {\n    id: 'tpl_fullstack_web',\n    category: TemplateCategory.WEB_APP,\n    name: 'Full-Stack Web Application',\n    description: 'Complete web app with React frontend and Node.js backend',\n    workflow: {\n      // Pre-configured workflow definition\n    }\n  },\n  {\n    id: 'tpl_ai_chatbot',\n    category: TemplateCategory.AI_MODEL,\n    name: 'AI Chatbot Service',\n    description: 'Intelligent chatbot with natural language processing',\n    workflow: {\n      // Pre-configured workflow definition\n    }\n  }\n];\n```\n\n## 7. Integration with Existing System\n\n### 7.1 Orchestrator Integration\n\n```typescript\nclass WorkflowExecutor {\n  private orchestrator: StarriOrchestrator;\n  private agentPool: AgentPool;\n  \n  async executeWorkflow(workflow: WorkflowDefinition): Promise<ExecutionResult> {\n    // Validate workflow\n    const validation = await this.validateWorkflow(workflow);\n    if (!validation.isValid) {\n      throw new WorkflowValidationError(validation.errors);\n    }\n    \n    // Create execution plan\n    const executionPlan = this.createExecutionPlan(workflow);\n    \n    // Execute with orchestrator\n    const result = await this.orchestrator.executeWorkflowPlan(executionPlan);\n    \n    return result;\n  }\n  \n  private createExecutionPlan(workflow: WorkflowDefinition): ExecutionPlan {\n    // Convert visual workflow to execution plan\n    const plan = new ExecutionPlan();\n    \n    // Topological sort for execution order\n    const executionOrder = this.topologicalSort(workflow.nodes, workflow.connections);\n    \n    // Create agent tasks\n    for (const nodeId of executionOrder) {\n      const node = workflow.nodes.find(n => n.id === nodeId);\n      if (node?.type === 'agent') {\n        plan.addTask({\n          agentType: node.data.agentType,\n          config: node.data.config,\n          dependencies: this.getNodeDependencies(nodeId, workflow.connections)\n        });\n      }\n    }\n    \n    return plan;\n  }\n}\n```\n\n### 7.2 WebSocket Real-time Updates\n\n```typescript\ninterface WorkflowWebSocketEvents {\n  'workflow.started': { workflowId: string; timestamp: Date };\n  'workflow.node.started': { workflowId: string; nodeId: string };\n  'workflow.node.progress': { workflowId: string; nodeId: string; progress: number };\n  'workflow.node.completed': { workflowId: string; nodeId: string; output: any };\n  'workflow.node.failed': { workflowId: string; nodeId: string; error: Error };\n  'workflow.completed': { workflowId: string; result: any };\n  'workflow.failed': { workflowId: string; error: Error };\n}\n```\n\n## 8. Visual Debugging Capabilities\n\n### 8.1 Debug Mode Features\n\n```typescript\ninterface DebugFeatures {\n  breakpoints: Set<string>;          // Node IDs with breakpoints\n  watchedVariables: string[];        // Variables to track\n  executionTrace: ExecutionTrace[];  // Step-by-step execution log\n  dataInspector: DataInspector;      // Inspect data at each node\n  timeTravel: TimeTravelDebugger;    // Replay execution\n}\n\nclass WorkflowDebugger {\n  async setBreakpoint(nodeId: string): Promise<void> {\n    this.breakpoints.add(nodeId);\n  }\n  \n  async stepInto(nodeId: string): Promise<void> {\n    // Execute single node and pause\n  }\n  \n  async inspectData(nodeId: string, portId: string): Promise<any> {\n    return this.dataFlow.get(`${nodeId}.${portId}`);\n  }\n  \n  async replayExecution(fromStep: number): Promise<void> {\n    // Replay workflow from specific step\n  }\n}\n```\n\n## 9. Responsive UI/UX Design\n\n### 9.1 Mobile-Responsive Canvas\n\n```typescript\nconst ResponsiveWorkflowEditor: React.FC = () => {\n  const [viewMode, setViewMode] = useState<'edit' | 'view' | 'compact'>('edit');\n  const { width, height } = useWindowSize();\n  \n  const canvasConfig = useMemo(() => {\n    if (width < 768) {\n      return {\n        mode: 'compact',\n        zoom: 0.7,\n        panEnabled: true,\n        editEnabled: false\n      };\n    } else if (width < 1024) {\n      return {\n        mode: 'tablet',\n        zoom: 0.85,\n        panEnabled: true,\n        editEnabled: true\n      };\n    } else {\n      return {\n        mode: 'desktop',\n        zoom: 1.0,\n        panEnabled: true,\n        editEnabled: true\n      };\n    }\n  }, [width]);\n  \n  return (\n    <div className=\"responsive-workflow-editor\">\n      {canvasConfig.mode !== 'compact' && <NodePalette />}\n      <WorkflowCanvas config={canvasConfig} />\n      {canvasConfig.mode === 'compact' && <CompactControls />}\n    </div>\n  );\n};\n```\n\n## 10. Performance Optimizations\n\n### 10.1 Canvas Rendering Optimization\n\n```typescript\n// Use React.memo and virtualization for large workflows\nconst OptimizedNode = React.memo<{ node: WorkflowNode }>(({ node }) => {\n  return <WorkflowNode {...node} />;\n}, (prevProps, nextProps) => {\n  // Custom comparison for re-render optimization\n  return prevProps.node.id === nextProps.node.id &&\n         prevProps.node.position.x === nextProps.node.position.x &&\n         prevProps.node.position.y === nextProps.node.position.y &&\n         prevProps.node.state === nextProps.node.state;\n});\n\n// Virtual scrolling for node palette\nconst VirtualizedNodePalette: React.FC = () => {\n  // Implementation using react-window or similar\n};\n```\n\nThis architecture provides a comprehensive foundation for building a powerful visual workflow system with drag-and-drop capabilities, real-time visualization, and seamless integration with the existing Nexus Forge agent orchestration system.",
  "summary": "Comprehensive visual workflow architecture with drag-drop nodes, real-time visualization, and debugging tools",
  "components": [
    "WorkflowEditor with drag-drop canvas",
    "Node system for different agent types",
    "Connection system for data flow",
    "Workflow serialization format",
    "Real-time execution visualization",
    "Visual debugging capabilities",
    "Responsive UI/UX design",
    "Integration with existing orchestrator"
  ]
}